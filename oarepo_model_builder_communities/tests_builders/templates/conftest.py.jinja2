import pytest
from invenio_access.permissions import system_identity
from invenio_communities import current_communities
from invenio_communities.communities.records.api import Community
from invenio_pidstore.errors import PIDDoesNotExistError
from flask_principal import Identity, Need, UserNeed

from flask_security import login_user
from invenio_accounts.testutils import login_user_via_session

@pytest.fixture()
def users(app, db):
    with db.session.begin_nested():
        datastore = app.extensions["security"].datastore
        user1 = datastore.create_user(
            email="community_owner@inveniosoftware.org",
            password="community_owner",
            active=True,
        )
        user2 = datastore.create_user(
            email="user2@example.org",
            password="beetlesmasher",
            active=True,
        )

    db.session.commit()
    return [user1, user2]

@pytest.fixture()
def identities():
    """Simple identity fixture."""
    i1 = Identity(1)
    i1.provides.add(UserNeed(1))
    i1.provides.add(Need(method="system_role", value="any_user"))
    i1.provides.add(Need(method="system_role", value="authenticated_user"))

    i2 = Identity(2)
    i2.provides.add(UserNeed(2))
    i2.provides.add(Need(method="system_role", value="any_user"))
    i2.provides.add(Need(method="system_role", value="authenticated_user"))
    return [i1, i2]


@pytest.fixture(scope="module")
def minimal_community():
    """Minimal community metadata."""
    return {
        "access": {
            "visibility": "public",
            "record_policy": "open",
        },
        "slug": "public",
        "metadata": {
            "title": "My Community",
        },
    }


@pytest.fixture(scope="module", autouse=True)
def location(location):
    return location


@pytest.fixture(scope="module")
def app_config(app_config):
    app_config["FILES_REST_STORAGE_CLASS_LIST"] = {
        "L": "Local",
        "F": "Fetch",
        "R": "Remote",
    }
    app_config["FILES_REST_DEFAULT_STORAGE_CLASS"] = "L"

    return app_config


@pytest.fixture()
def get_or_create_community():
    def _get_or_create_community(identity, data):
        """Util to get or create community, to avoid duplicate error."""
        slug = data["slug"]
        try:
            c = current_communities.service.record_cls.pid.resolve(slug)
        except PIDDoesNotExistError:
            c = current_communities.service.create(
                identity,
                data,
            )
            Community.index.refresh()
            c = current_communities.service.record_cls.pid.resolve(slug)
        return c

    return _get_or_create_community

#----
@pytest.fixture()
def client_logged_as(client, users):
    """Logs in a user to the client."""

    def log_user(user_email):
        """Log the user."""
        available_users = users

        user = next((u for u in available_users if u.email == user_email), None)
        login_user(user, remember=True)
        login_user_via_session(client, email=user_email)
        return client

    return log_user


@pytest.fixture()
def logged_client_request(client_logged_as):
    def _logged_client_request(user, method, *args, **kwargs):
        applied_client = client_logged_as(user.email)
        return getattr(applied_client, method)(*args, **kwargs)

    return _logged_client_request


@pytest.fixture
def create_record_with_community(get_or_create_community, logged_client_request, base_urls):
    def _create_record_with_community(
        identity, owner, community_dict
    ):
        community = get_or_create_community(identity, community_dict)
        community_id = str(community.id)

        response = logged_client_request(owner, "post",
                                         f"{base_urls['base_community_records_url']}{community_id}/records", json={}
                                         )
        return response
    return _create_record_with_community


@pytest.fixture
def publish_record(record_service):
    def _publish_record(record):
        return record_service.publish(system_identity, record.json["id"])
    return _publish_record
